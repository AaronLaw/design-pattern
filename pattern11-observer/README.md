## 观察者模式

**模式定义**

定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

## 优点
1. 观察者模式实现了观察者和目标之间的抽象耦合
原本目标对象在状态发生改变的时候，需要直接调用所有的观察者对象，但是抽象出观察者接口以后，
目标和观察者就只是在抽象层面上耦合了，也就是说目标只是知道观察者接口，并不知道具体的观察者的类，
从而实现目标类和具体的观察者类之间解耦。
1. 观察者模式实现了动态联动
所谓联动，就是做一个操作会引起其他相关的操作。由于观察者模式对观察者注册实行管理，那就可以在运行期间，
通过动态地控制注册的观察者，来控制某个动作的联动范围，从而实现动态联动。
1. 观察者模式支持广播通信
由于目标发送通知给观察者是面向所有注册的观察者，所以每次目标通知的信息就要对所有注册的观察者进行广播。
当然，也可以通过在目标上添加新的功能来限制广播的范围。

## 缺点
1. 可能会引起无谓的操作
由于观察者模式每次都是广播通信，不管观察者需不需要，每个观察者都会被调用update 方法，
如果观察者不需要执行相应处理，那么这次操作就浪费了。

## 本质
观察者模式的本质：触发联动。

## 使用场景

建议在以下情况中选用观察者模式。

1. 当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化，
那么就可以选用观察者模式，将这两者封装成观察者和目标对象，当目标对象变化的时候，依赖于它的观察者对象也会发生相应的变化。
这样就把抽象模型的这两个方面分离开了，使得它们可以独立地改变和复用。
1. 如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变，
这种情况可以选用观察者模式，被更改的那一个对象很明显就相当于是目标对象，而需要连带修改的多个其他对象，
就作为多个观察者对象了。
1. 当一个对象必须通知其他的对象，但是你又希望这个对象和其他被它通知的对象是松散耦合的。
也就是说这个对象其实不想知道具体被通知的对象。这种情况可以选用观察者模式，这个对象就相当于是目标对象，
而被它通知的对象就是观察者对象了。

