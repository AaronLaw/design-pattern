## 抽象工厂模式

**模式定义**

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

从某种意义上看，抽象工厂其实是为了创建一个产品系列，或者是产品簇，这些产品相互之间是相关或有依赖的。

## 优点
1. 分离接口和实现
客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。
也就是说，客户端从具体的产品实现中解耦。
2. 使得切换产品簇变得容易
因为一个具体的工厂实现代表的是一个产品簇，比如上面例子的Scheme1 代表装机方案一：Intel 的CPU + 技嘉的主板，
如果要切换成为Scheme2，那就变成了装机方案二：AMD 的CPU + 微星的主板。客户端选用不同的工厂实现，就相当于是在切换不同的产品簇。

## 缺点
1. 不太容易扩展新的产品
前面也提到这个问题了，如果需要给整个产品簇添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。
在前面提供了一个可以扩展工厂的方式来解决这个问题，但是又不够安全。如何选择， 则要根据实际应用来权衡。
2. 容易造成类层次复杂
在使用抽象工厂模式的时候，如果需要选择的层次过多，那么会造成整个类层次变得复杂。
举个例子来说，就比如前面讲到的DAO 的示例，现在这个DAO 只有一个选择的层次，也就是选择是使用关系型数据库来实现，
还是用Xml 来实现。现在考虑这样一种情况，如果关系型数据库实现里面又分成几种，
比如，基于Oracle的实现、基于SqlServer 的实现、基于MySql 的实现等。
那么客户端怎么选择呢？不会把所有可能的实现情况全部都做到一个层次上吧，这个时候客户端就需要一层一层地选择，
也就是整个抽象工厂的实现也需要分出层次来，每一层负责一种选择，也就是一层屏蔽一种变化，这样很容易造成复杂的类层次结构。

## 本质
抽象工厂模式的本质：选择产品簇的实现。

## 使用场景

建议在以下情况中选用抽象工厂模式。

1. 如果希望一个系统独立于它的产品的创建、组合和表示的时候。换句话说，希望一个系统只是知道产品的接口，而不关心实现的时候。
2. 如果一个系统要由多个产品系列中的一个来配置的时候。换句话说，就是可以动态地切换产品簇的时候。
3. 如果要强调一系列相关产品的接口，以便联合使用它们的时候。

